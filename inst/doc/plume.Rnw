% \VignetteIndexEntry{An Introduction to Gaussian Dispersion Modeling in R} 
% \VignetteKeywords{plume,atmospheric,dispersion,modeling}
% \VignetteDepends{ggplot2}
% \VignettePackage{plume}

\documentclass{article}

\usepackage{amsmath}
\usepackage{amscd}
\usepackage[tableposition=top]{caption}
\usepackage{ifthen}
\usepackage[utf8]{inputenc}

\begin{document}

\title{An Introduction to Steady-State Gaussian Dispersion Modeling in R}
\author{David Holstius}
\maketitle

\section{Introduction}

This vignette is a brief introduction to \verb@plume@, a package that illustrates the basics of atmospheric dispersion modeling in R. The package itself is an example of a tool for reproducible environmental modeling research, complete with test cases and documentation (including this document). 

Throughout this vignette we will make use of the excellent \verb@ggplot2@ package created by Hadley Wickham. For more information on creating plots with \verb@ggplot2@, type \verb@help(package='ggplot2')@ at the R prompt. We will also work toward integrating with the \verb@sp@ library, a foundational package for anyone working with spatial data in R.
 
<<load_packages>>=
require(ggplot2)
require(plume)
@

\section{Steady-State Gaussian Dispersion}

Assuming a point source with constant emission rate $Q$ and a steady wind field with speed $u$, the concentration $C$ at any location $(x, y, z)$ downwind can be conceptualized as the product of three terms: 

$$
C = \frac{Q}{u} \cdot \frac{f}{\sigma_y\sqrt{2\pi}} \cdot \frac{g}{\sigma_z\sqrt{2\pi}}
$$

where

$$
f = exp\left[\frac{-y^2}{2\sigma_y^2)}\right]
$$

and 

$$
g = exp\left[\frac{-(z-H)^2}{2\sigma_z^2}\right] + 
      exp\left[\frac{-(z+H)^2}{2\sigma_z^2)}\right]
$$

From the first term we can see that $C$ is directly proportional to $Q$, and inversely proportional to $u$. Thus, the equation is ill-defined for low wind speeds (as $u$ goes to $0$, $C$ goes to infinity).

The second term captures the crosswind diffusivity, and the third term captures the vertical diffusivity. Both $\sigma_y$ and $\sigma_z$ are curves parameterized by $x$ (not constants). At any fixed distance $x$ from the source, the cross-section of the plume is a continuous two-dimensional Gaussian distribution described by the these two terms (hence the name).

\section{Modeling Point Sources}

In this very basic example, the plume shape will be fully described by the emission source and the prevailing meteorology. We imagine the ground to be like a mirror: perfectly level, frictionless, and flat. Rather than absorbing the plume aerosol, the ground will ``reflect'' it back toward the sky. 

The emission source, which might be something like an incinerator stack, is described by two parameters: the emission rate $Q$, and the release height $H$. $Q$ is given in grams per second (g/s), and $H$ in meters (m) above ground level. 

The wind must be blowing at least 1.0 meters per second (m/s). Under these conditions, the transport of the plume aerosol is dominated by advection, and not by lateral or vertical diffusion. The orientation of the wind field is, by definition, parallel to the x-axis.

<<define_plume>>=
plume <- GaussianPlume(Q=50.0, H=10.0, u=2.0, sigma=PasquillGifford('D'))
@

Diffusion does occur, however. The diffusivity field ($\sigma$) describes the lateral ($\sigma_y$) and vertical ($\sigma_z$) diffusivity at distance $x$ from the source (at $(0, 0)$). In theory, any \verb@sigma@ function may be supplied, as long as it accepts a numeric vector $x$ and returns a list with numeric $y$ and $z$ components. The \verb@plume@ package supplies a function \verb@PasquillGifford@, which relies on the same experimentally derived parameters used in the U.S. EPA's Industrial Source Control (ISC) family of models.

It's worth noting that the function \verb@PasquillGifford@ is a \textit{factory function}: a function that returns another function. \verb@PasquillGifford@ takes a single parameter, \verb@stability@, which is the Pasquill stability class corresponding to prevailing meteorological conditions. This in turn parameterizes the curves $\sigma_y$ and $\sigma_z$. For an illustration of the curves corresponding to different values of \verb@stability@, see Section  \ref{sec:Pasquill-Gifford Curves}.

The first thing to do is construct a receptor grid. Our coordinate frame is in meters; all locations are relative to the emission source, which is at $(0, 0)$. The positive x-axis corresponds to the direction the wind is blowing. 

<<construct_grid>>=
resolution <- 20
x <- seq(10, 2000, by=resolution)
y <- seq(-500, 500, by=resolution)
receptors <- as.matrix(expand.grid(x=x, y=y, z=1.8))
@

Here, we construct a grid with \Sexpr{resolution}-meter spacing. We set the receptor height ($z$) to 1.8 meters, corresponding to the height of an ``average'' adult.


<<predict_concentrations>>=
system.time(pred <- plume(receptors))
cells <- data.frame(receptors, mgm3 = pred * 1e3)
@

<<plot_heatmap,fig=TRUE>>=
ggplot(subset(cells, mgm3 > 0.001), aes(x, y)) + coord_equal() +
	geom_tile(aes(alpha=mgm3), fill='red') +
	scale_x_continuous(limits=c(0, max(x)), expand=c(0, 0)) +
	scale_y_continuous(limits=c(-1000, 1000), expand=c(0, 0)) +
	scale_fill_continuous() + 
	scale_alpha(expression(over(mg, m^3)), to=c(0, 1))
@

\appendix{Appendix}

\section{Pasquill-Gifford Curves}

<<sigma_curves>>=
stability <- LETTERS[1:6]
curves <- lapply(stability, PasquillGifford)
names(curves) <- stability
x <- 10 ^ seq(0, 5, by=0.1)
values <- ldply(curves, function(sigma) data.frame(sigma(x)))
values <- rename(values, c(.id='Pasquill'))
@

<<sigma_y,fig=TRUE>>=
p <- ggplot(values) + geom_line(aes(x, y, color=Pasquill))
ordinate <- scale_x_log10('distance to source, x (m)', 
	breaks = 10^(0:5),
	minor_breaks = as.vector(outer(1:10, 10^(0:5))))
abscissa <- scale_y_log10(expression(sigma[y]), 
	breaks = 10^(-1:4),
	minor_breaks = as.vector(outer(1:10, 10^(-1:4))))
show(p + ordinate + abscissa + coord_equal())
@

<<sigma_z,fig=TRUE>>=
p <- ggplot(values) + geom_line(aes(x, z, color=Pasquill))
abscissa <- scale_y_log10(expression(sigma[z]), 
	breaks = 10^(-1:4),
	minor_breaks = as.vector(outer(1:10, 10^(-1:4))))
show(p + ordinate + abscissa + coord_equal())
@


\end{document}
